JVM在默认的情况下是刚开始启动的时候是关闭偏向锁的，可以通过参数设置偏向锁开启的时间：-XX:BiasedLockingStartupDelay=4单位为秒，及默认JVM在4s后开启偏向锁
synchronized(obj){
.....
}代码块A

1.没有开启偏向锁，没有线程竞争时，当线程A访问代码块A时，直接升级为轻量级锁，markword=000，并在markword中记录线程A的栈中LR的地址，和在线程A栈中的LR指针指向的对象中存放obj对象头的markword值
2.没有开启偏向锁，当有线程竞争时，及线程A、B同时访问代码块A，直接升级为重量级锁，markword=10，在markword中记录ObjectMonitor对象的指针
3.开启偏向锁，没有线程竞争时，当线程A访问代码块A时，升级为偏向锁，markword=101，在markword中记录记录线程A的线程ID
3.开启偏向锁，有线程竞争时，当A、B线程同时访问代码块A时，A、B通过cas操作往obj对象的markword中记录A或B栈中LR的地址，A或B写入成功，表示A或B得到锁，此时obj进入轻量级锁，obj的markword=000，markword值为线程ID
4.开启偏向锁，有线程竞争时，当A、B线程同时访问代码块A时，当A、B其中某个线程cas次数超过一定次数时或者竞争obje对象的锁的线程数过多，obj对象锁变为重量级锁

偏向锁、轻量级锁 关于sync锁重入的实现：当A获取到锁时并重入方法时，在A栈中压入一个LR指针，LR指针指向的对象的值为NULL，退出方法时，弹出一个LR指针



CAS：线程A先取出A的值a，然后设置一个新的值b，当设置值的时候比较现在A内存中的值是不是还是a，若是就将A设置为b，底层通过lock cas操作实现

ABA：当线程A取出A的值a时，然后设置一个新的值b，当设置值的时候比较现在A内存中的值是不是还是a，若是就将A设置为b
    在比较的时候，此时会存在这种情况：线程B 通过CAS将A的值从a设置为c并成功了，线程C通过CAS将A的值从c设置为a也成功了，这种现象就是ABA

ABA的解决方案：值版本号，及没更新过一次版本号+1

